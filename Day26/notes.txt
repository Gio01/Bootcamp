python virtual env:
    - these are more like a protected directory which will be activated when we run the env 
    - these env are used in order to contain python version for the interpreter
    - as well as any other dependencies that are needed for the application that we are running!

installing SQL Alchemy
    python -m pip install SQLAlchemy

The benefit of using SQLAlchemy is that it can be used to connect to many different SQL flavors and hence
has an advantage over something like the built in python sqlite3 lib since that is only for SQLite and 
SQLAlchemy can be used for SQLite and many more other SQL DBs


Connecting to SQLAlchemy:


#creating the engine in order to talk to the sqlite db and then text is for the sql statement creation
from sqlalchemy import create_engine, text

engine = create_engine("sqlite:///./books.db", echo=True) #here sqltie:/// is how the engine knows it is 
#going to be sqlite and then we just give the location of the file which is ./book.db in this case since we 
#are in that directory already

#create the connection to the db
conn = engine.connect()

#execute a SQL statement
result = conn.execute(text("select * from author"))

#print out the result
print(result.all()) #or you can do a for loop through each of the rows in result!

for row in result:
    print(f"{row.last_name}, {row.first_name}") #this is based on the column names which are the names in the table!

for _, first_name, last_name in result: #this is for doing unpacking through the iteration! recall _ means we do not want that
    print(first_name, last_name) #value and in this case that would be the author_id value! 

for dict_row in result.mappings():
    print(dict_row) #this will give us the data in the form of a dictionary!

'''
Now when we get the result we get back a cursor object which is called this because once we get the results and
we print them, if we try to print the results again from that same all() we will get an empty list as it is
discarded! So we will need to re execute the sql statement for select * from author in order to get the 
results again in the result var!!
'''



#SQL injection -> when the user has direct access to the values that are being inserted into the db! This is bad and hence
#a safety mechanism is to used prepared statments instead and these are then able to be used through a placeholder such as :fn
#SQL Server engine treats user data (the data that is sent into the prepared statments) as pure data and not a SQL that needs 
#to be parsed or compiled again; that is the beauty of PreparedStatement. Meaning that any data that we give which would be an SQL
#statement will not be read as a SQL statement but a raw string and hence will not execute that SQL command and hence we can avoid SQL
#injection

conn.execute(text("insert into author (first_name, last_name) values (:fn, :ln)"),  [{"fn": "Jane", "ln": "Doe"}])


#transactions:
txn = conn.begin()

#committing a transaction
txt.commit()

#rollbacking a transaction
txn.rollback()


#now the use of a transaction is so that instead of executing the same SQL command again and again we can create a
#transaction which is a unit or sequence of works that you want to execute! 


#a way by which we can bind params (give the param a value) through the use of a prepared statament!
stmt = text("select last_name from author where last_name > :ln")
stmt = stmt.bindparams(ln="C")
result = conn.execute(stmt)

#updating a value from the table!
stm = text("update author set first_name = :name  where first_name='giovanni'")
stm = stm.bindparams(name="Giovanni")
conn.execute(stm)
result = conn.execute('select * from author')
print(result.all())

#deleting a row from a table!
stm2 = text('delete from author where last_name = :lname')
stm2 = stm2.bindparams(lname="Doe")
conn.execute(stm2)
result = conn.execute('select * from author')
print(result.all())

 
SQLAlchemy statement features (Core)

    from sqlalchemy import create_engine
    engine = create_engine("sqlite:///./books.db", echo=True, future=True)
    conn = engine.connect()
    from sqlalchemy import MetaData, Table
    metadata = MetaData()
    author_table = Table("author", metadata, autoload_with=engine)

So here what is happening is that again we create the engine and then we are then 
trying to get the metadata from the table which would be the basic table info such as 
the column names!! Then when we create the Table we use the table name we want, the 
metadata instance which will get that metadata for us from pointing the autoload_with to
be that of the engine which in this case is the actul db file that we want!

We can even use sqlalchemy to create SQL statements on the fly by pointing that to the 
metadata table which we created by using the Table() function above!! 

from sqlalchemy import select
select(author_table)
stm = select(author_table)
print(stm) #SELECT author.author_id, author.first_name, author.last_name
FROM author 
#which means that the select function will automatically create this select statment for us! 
result = conn.execute(stm)
print(result.all())


#We can also chain stataments such as using a select and then adding a where condition!
stm2 = select(author_table).where(author_table.c.first_name == "Gio") #c here is referring to col names
print(stm2)
SELECT author.author_id, author.first_name, author.last_name
FROM author
WHERE author.first_name = :first_name_1

#NOTE: Internally it is creating a prepared statament! As you see it creates the statament with
:first_name_1 and this means that we are safe from SQL injection in this manner! 

result = conn.execute(stm)
print(result.all()) #[(9, 'Gio', 'Ordonez')]


#insert
from sqlalchemy import insert
stm3 = insert(author_table).values(first_name="haruki", last_name="murakami")
conn.execute(stm3)

#inserting multiple rows
insert_stmt = insert(author_table)
    conn.execute(insert_stmt, 
        [{"first_name" : "f1", "last_name" : "l1"}, {"first_name" : "f2", "last_name" : "l2"}]
    )



engine = create_engine("sqlite:///./books.db", echo=True, future=True)

NOTE: when we use future true, a transaction is created and any changes we make will
not be commited until we explicitely do conn.commit()!!! Meaning that any change we make
before doing commit() will not cause a permanent change in the table until we run
conn.commit()!!!

Once we do conn.commit() a new transaction is created!!

Now the benefit in this is that since these are transactions this means that we can 
rollback transaction changes and hence if there is some mistake or some error we can 
default back to the previous data that was there before we had tried to commit some changes!!

Hence it is advisable for us to always use this future = True so that we can use transactions!!


#update
    from sqlalchemy import update
    update_stmt = update(author_table).where(author_table.c.first_name=="f1").values(first_name="Barry", last_name="Schwartz")
    conn.execute(update_stmt)


#delete 
    from sqlalchemy import delete
    delete_stmt = delete(author_table).where(author_table.c.author_id == 13)


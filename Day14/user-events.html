<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        (function(){
            function doWork(onComplete, onProgress){
                var totalIterations = 1000,
                    currentIteration = 0;

                function oneIteration(){
                    for(var i=0; i < (10000/totalIterations); i++)
                        for(var j=0; j < 5000; j++)
                            for(var k=0; k < 1000; k++){

                            }
                    ++currentIteration;
                    if (currentIteration % 10 === 0) {
                        var percentCompletion = (currentIteration/totalIterations) * 100;
                        onProgress(percentCompletion);
                    }
                    if (currentIteration < totalIterations){
                        setTimeout(oneIteration)
                    } else {
                        console.log('Job Done');
                        onComplete()
                    }
                }

                setTimeout(oneIteration);
            }
            /**
             * So here with the setTimeout it allows for execution of the function to 
             * happen after a small period of time and in the browser we have the scheduler
             * which will cause for things to happen sequencially within he browser!
             * 
             * scheduler queue: [ fn, user event, fn, user event, fn, user event, fn]
             * 
             * Now what is really happening here is that since we break up the iterations
             * into smaller chunks then we are allowing for user interactions to stil happen!
             * 
             * Now remember that user action are also events and the scheduler takes in 
             * events that the thread in the browser will run through based on what 
             * is being added into the queue. So really what happens in this scenerio is 
             * that the scheduler queue is recieving individual oneIteraion functions into 
             * the queue and when the user does something those events are also being 
             * added into the queue!! Meaning that both the function runnin event and the 
             * user event can be handled, now this is because the thread is switching 
             * between the events so fast that for us on the broswer it appears that things
             * are happening asynchronously but really what is happening is that the event
             * tasks are being switched between the function interation event and the user 
             * event so fast that it appears it happens asynchronously!!! 
             * 
             * Remember that there are no multiple threads in the browser tab so this is how we 
             * can achieve "asynchronous" like operations in the broswer. If we had multiple
             * threads then we would give that other thread the job of running hat interation
             * function!
             * 
             * Web apps on the web are given a single thread and that is why we need 
             * to do this in order to get this asynchronous like behavior!
             * 
             * Another way in which we can do this is use WebWorkers! 
             * 
             * Another way we can do this is to use Observables which will chunk data 
             * and give it to us as it becomes available! Meaning that the browser does 
             * not need to be waiting for the entire process to be done, it can continue to
             * handle other user interactions while it waits to get data to be supplied!
             * 
             * Observerables are lazy push collections meaning that it will give us the 
             * data as it becomes available!! So essentially it is able to give us the data 
             * without blocking the processes of the browser or other user interactions to 
             * happen!! 
             * 
             * we cannot use promises since they will wait until all the data is available and
             * then give that to the variable!! That is not what we want to happen either
             * because while 
             */

            function displayMessage(msg){
                var divMessagesDOM = document.getElementById('divMessages');
                divMessagesDOM.innerHTML += msg + '<br/>'; 
            }

            function onBtnDoWorkClick(){
                displayMessage('work started'); //dom updated, NO screen repaint
                setTimeout(triggerWork)
            }

            function triggerWork(){
                doWork(onWorkCompletion, onWorkProgress);
            }

            function onWorkCompletion(){
                 displayMessage('work completed');
            };

            function onWorkProgress(percentCompletion){
                document.getElementById('workProgress').value = percentCompletion;
            }

            function onDocumentLoad(){
                var btnDoWork = document.getElementById('btnDoWork');
                btnDoWork.addEventListener('click', onBtnDoWorkClick);
            }
            window.addEventListener('load', onDocumentLoad);
        })();

    </script>
</head>
<body>
    <input type="text" name="" id="">
    <button id="btnDoWork">Do Work</button>
    <div>
        <progress id="workProgress" min="0" max="100" value="0"></progress>
    </div>
    <div id="divMessages"></div>
</body>
</html>
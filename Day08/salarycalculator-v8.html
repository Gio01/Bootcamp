<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salary Calculator</title>
    <style>
        body{
            margin-left: 50px;
        }
        .field{
            margin-bottom: 10px;
        }
        label{
            display: block;
        }
        td{
            padding-right: 10px;
            font-size: 18pt;
        }
    </style>
    <script src="jquery-3.6.0.js"></script>
    <script>
        //Model
        /* state & behavior */
        class SalaryCalculatorModel {
            //state
            _data = {
                basic : 0,
                hra : 0,
                da : 0,
                tax : 0,
                salary : 0
            };

            _callbacks = {
                basic : [],
                hra : [],
                da : [],
                tax : [],
                salary : []
            };
            /**
             * So what is happening now is that we created an array and associated
             * them to these different attributes so that we can give multiple
             * callback functions to the same class attribute! In this manner
             * when we set one value to the attributes, we will execute all 
             * of the callback functions within the array! In this manner 
             * we can then do many intances of the views and have the model
             * send that data to the views as each callback function would
             * point to a view!
             * 
             * Ex: When we use the console and treat it is a second view, 
             * what happens is that we can call the set with a callbackfunction
             * to console.log something but within this html view we also 
             * have a method that has a callback which will get the value of the
             * attribute name such as:
             * model.subscribe('salary', function(){
                $('#tdSalary').text(model.get('salary'));
            });

            and then in the console we can run:
            model.subscribe('salary', function() {console.log("invoke salary")})


            so essentially now we have two callback functions which are added 
            into the array of callbacks for the attribute of salary! Meaning
            that if we click the calculate button the salary will be displayed
            on the view from the : model.subscribe('salary', function(){
                $('#tdSalary').text(model.get('salary'));
            });
            as well as ffrom the 
            model.subscribe('salary', function() {console.log("invoke salary")})
            
            call, but what happens is that when we set the value! It will 
            automatlly execute all of the callback functions within the
            callbacks for salary attribute as seen in the set() code with the
            forEach and running each of the functions within the salary array!

            Essentially when we set a value we will run all of the callback 
            functions that are within the array for that certain attribute that
            we are setting the value!! 

            Sequence: we added a callback in the console!
            salary: [$('#tdSalary').text(model.get('salary'));, function() {console.log("invoke salary")}]

            -> click calculate -> calculate() runs and calls set('salary') -> set() will
            run a forEach for all of the callbacks in the salary []!!
             */

            subscribe(attrName, callbackFn){
                if (typeof callbackFn !== 'function') return;
                this._callbacks[attrName].push(callbackFn);
            }

            get(attrName){
                return this._data[attrName];
            }

            set(attrName, val){
                this._data[attrName] = val;
                let callbackFns = this._callbacks[attrName];
                callbackFns.forEach(callbackFn => callbackFn())
            }
            
            /*
            Here we are now creating the get and set methods so that instead
            of having to copy and paste the methods for each of the attributes
            we can do it in a dynamic fasion by justing needednig to pass in 
            the attribute name as the functionality is the same regardless 
            of what the attribute is! 
            */

            //behavior
            calculate(){
                let gross = this.get('basic') + this.get('hra') + this.get('da'),
                    net = gross * ((100-this.get('tax'))/100);
                this.set('salary', net);
                
            }
            
        }

        /*
            The reason in now creating a class is so that we now have seperation 
            in the calculator logic and that of the displaying of the data onto
            the UI. In this manner we seperate the responsabilities of the calc 
            and the UI! 

            This will help us to be able to better maintain the application in the
            long run as we now know that if we need to make a change to the calc
            functionality then we need to go to the class and not look into the UI
            in the JQuery area and then if we need to change something within the
            UI and how data is displayed then we will go into the JQuery area
            in order to then make the changes we want for the UI of the application

            However even now we still have some issues! What else do we need to 
            change now to make this ready for deployment?
            - We have an issue of tight coupling where If I make some change within the
            Calc class such as addnig a new variable state, then uppon creating it 
            and then using it in the calculate function, we will then need to go to the
            UI Jquery to also be able to get the user to supply data to that new 
            variable! In this manner it means that calculate relies on the data given 
            by the JQuery UI. 
                > Now how can we remove this dependancy (tight coupling) between the
                Model calculate() and that of the data from the UI in the case where
                we add a new variale or make changes within the class 


            So instead we will use change() instead of click() so that we do not need
            to wait until the user inputs all the data and clicks on the button 
            but rather we can simply get data from the user from when ever they 
            give it and hence becomes available!
            
        */ 

        //View
        $(function(){
            
            //let model = new SalaryCalculatorModel();

            window['model'] = new SalaryCalculatorModel();

            /*
            Here we now have call back functions that will set the value
            to each attribute based on what is inserted into the text box 
            input for each of the attributes in the UI!!
            */
            $('#txtBasic').change(function(){
                model.set('basic', parseInt($(this).val()));
            });

            $('#txtHra').change(function () {
                model.set('hra', parseInt($(this).val()));
            });

            $('#txtDa').change(function () {
                model.set('da', parseInt($(this).val()));
            });

            $('#rangeTax').change(function () {
                model.set('tax', parseInt($(this).val()));
            });


            //here we only have a single button and we have the click listener
            //so that it runs the calculate method when clicked
            $('#btnCalculate').click(function () {
                model.calculate();
            });

            /*
            Here we now have a means of getting the data automatically from the 
            model! This works because when the attribute gets changed, the model
            will return the callback function which will point back to this 
            callback function we define below which then calls the model.get to 
            output the data onto the UI!
            */
            model.subscribe('salary', function(){
                $('#tdSalary').text(model.get('salary'));
            });

            model.subscribe('basic', function(){
                $('#tdBasic').text(model.get('basic'));
            });

            model.subscribe('hra', function () {
                $('#tdHra').text(model.get('hra'));
            });

            model.subscribe('da', function () {
                $('#tdDa').text(model.get('da'));
            });

            model.subscribe('tax', function () {
                $('#tdTax').text(model.get('tax'));
            });
            
        });
    </script>
</head>
<body>
    <h1>Salary Calculator</h1>
    <hr>
    <div class="field">
        <label for="">Basic :</label>
        <input type="number" name="" id="txtBasic">
    </div>
    <div class="field">
        <label for="">HRA :</label>
        <input type="number" name="" id="txtHra">
    </div>
    <div class="field">
        <label for="">DA :</label>
        <input type="number" name="" id="txtDa">
    </div>
    <div class="field">
        <label for="">Tax :</label>
        <input type="range" name="" id="rangeTax" min="0" max="30" value="0">
    </div>
    <div class="field">
        <button id="btnCalculate">Calculate</button>
    </div>
    <div class="field">
        <table>
            <tbody>
                <tr>
                    <td id="tdBasic">[basic]</td>
                    <td id="tdHra">[hra]</td>
                    <td id="tdDa">[da]</td>
                    <td id="tdTax">[tax]</td>
                    <td id="tdSalary">[salary]</td>
                </tr>
            </tbody>
        </table>
    </div>
</body>
</html>
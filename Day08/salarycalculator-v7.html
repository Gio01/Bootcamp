<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salary Calculator</title>
    <style>
        body{
            margin-left: 50px;
        }
        .field{
            margin-bottom: 10px;
        }
        label{
            display: block;
        }
        td{
            padding-right: 10px;
            font-size: 18pt;
        }
    </style>
    <script src="jquery-3.6.0.js"></script>
    <script>
        //Model
        /* state & behavior */
        class SalaryCalculatorModel {
            //state
            _data = {
                basic : 0,
                hra : 0,
                da : 0,
                tax : 0,
                salary : 0
            };

            _callbacks = {
                basic: null,
                hra: null,
                da: null,
                tax: null,
                salary: null
            }

            /*
            What we are doing here is creating an object called callbacks which
            will contain all of the callback functions that we need instead of 
            needing to continue to write:
            onSalaryChange = null;
            onBasicChange = null;
            onDaChange = null;
            onTaxChange = null;

            and now we can do this._callback[funcname] in order to then have 
            access to the function! This makes the code cleaner! Remember we do not
            want to have repeatable code! 
            */
            subscribe(attrName, callbackFn){
                this._callbacks[attrName] = callbackFn;
            }

            get(attrName){
                return this._data[attrName];
            }

            set(attrName, val){
                this._data[attrName] = val;
                let callbackFn = this._callbacks[attrName];
                if (typeof callbackFn === 'function')
                    callbackFn();
            }
            
            /*
            Here we are now creating the get and set methods so that instead
            of having to copy and paste the methods for each of the attributes
            we can do it in a dynamic fasion by justing needednig to pass in 
            the attribute name as the functionality is the same regardless 
            of what the attribute is! 
            */

            //behavior
            calculate(){
                let gross = this.get('basic') + this.get('hra') + this.get('da'),
                    net = gross * ((100-this.get('tax'))/100);
                this.set('salary', net);
                
            }
            
        }

        /*
            The reason in now creating a class is so that we now have seperation 
            in the calculator logic and that of the displaying of the data onto
            the UI. In this manner we seperate the responsabilities of the calc 
            and the UI! 

            This will help us to be able to better maintain the application in the
            long run as we now know that if we need to make a change to the calc
            functionality then we need to go to the class and not look into the UI
            in the JQuery area and then if we need to change something within the
            UI and how data is displayed then we will go into the JQuery area
            in order to then make the changes we want for the UI of the application

            However even now we still have some issues! What else do we need to 
            change now to make this ready for deployment?
            - We have an issue of tight coupling where If I make some change within the
            Calc class such as addnig a new variable state, then uppon creating it 
            and then using it in the calculate function, we will then need to go to the
            UI Jquery to also be able to get the user to supply data to that new 
            variable! In this manner it means that calculate relies on the data given 
            by the JQuery UI. 
                > Now how can we remove this dependancy (tight coupling) between the
                Model calculate() and that of the data from the UI in the case where
                we add a new variale or make changes within the class 


            So instead we will use change() instead of click() so that we do not need
            to wait until the user inputs all the data and clicks on the button 
            but rather we can simply get data from the user from when ever they 
            give it and hence becomes available!
            
        */ 

        //View
        $(function(){
            
            //let model = new SalaryCalculatorModel();

            window['model'] = new SalaryCalculatorModel();

            /*
            Here we now have call back functions that will set the value
            to each attribute based on what is inserted into the text box 
            input for each of the attributes in the UI!!
            */
            $('#txtBasic').change(function(){
                model.set('basic', parseInt($(this).val()));
            });

            $('#txtHra').change(function () {
                model.set('hra', parseInt($(this).val()));
            });

            $('#txtDa').change(function () {
                model.set('da', parseInt($(this).val()));
            });

            $('#rangeTax').change(function () {
                model.set('tax', parseInt($(this).val()));
            });


            //here we only have a single button and we have the click listener
            //so that it runs the calculate method when clicked
            $('#btnCalculate').click(function () {
                model.calculate();
            });

            /*
            Here we now have a means of getting the data automatically from the 
            model! This works because when the attribute gets changed, the model
            will return the callback function which will point back to this 
            callback function we define below which then calls the model.get to 
            output the data onto the UI!
            */
            model.subscribe('salary', function(){
                $('#tdSalary').text(model.get('salary'));
            });

            model.subscribe('basic', function(){
                $('#tdBasic').text(model.get('basic'));
            });

            model.subscribe('hra', function () {
                $('#tdHra').text(model.get('hra'));
            });

            model.subscribe('da', function () {
                $('#tdDa').text(model.get('da'));
            });

            model.subscribe('tax', function () {
                $('#tdTax').text(model.get('tax'));
            });
            
        });
    </script>
</head>
<body>
    <h1>Salary Calculator</h1>
    <hr>
    <div class="field">
        <label for="">Basic :</label>
        <input type="number" name="" id="txtBasic">
    </div>
    <div class="field">
        <label for="">HRA :</label>
        <input type="number" name="" id="txtHra">
    </div>
    <div class="field">
        <label for="">DA :</label>
        <input type="number" name="" id="txtDa">
    </div>
    <div class="field">
        <label for="">Tax :</label>
        <input type="range" name="" id="rangeTax" min="0" max="30" value="0">
    </div>
    <div class="field">
        <button id="btnCalculate">Calculate</button>
    </div>
    <div class="field">
        <table>
            <tbody>
                <tr>
                    <td id="tdBasic">[basic]</td>
                    <td id="tdHra">[hra]</td>
                    <td id="tdDa">[da]</td>
                    <td id="tdTax">[tax]</td>
                    <td id="tdSalary">[salary]</td>
                </tr>
            </tbody>
        </table>
    </div>
</body>
</html>